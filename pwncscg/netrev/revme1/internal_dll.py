#! /bin/python
import base64
from Crypto.Cipher import AES
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Util.Padding import pad


# dotnet ReMe.dll CanIHazFlag? n0w_u_know_st4t1c_and_dynamic_dotNet_R3333
#Flag 2
class byteRocks():
	
	def __init__(self, btarray):
		self.btarray = btarray
	
	def isEmptyLocate(self, candidate):

		if (len(self.btarray)==0 or len(candidate)==0):
			return True
		else:
			return False

	def isMatch(self, pos, candidate):
		
		flag = len(candidate) > len(self.btarray) - pos
		if flag:
			return False
		else:

			for i in range(len(candidate)):
				if self.btarray[pos+i] != candidate[i]:
					return False

			return True

	def Locate(self,candidate):
	
		flag = self.isEmptyLocate(candidate)
		res = []
		if (flag):
			return res
		for i in range(len(self.btarray)):
			flag = self.isMatch(i,candidate)
			if flag:
				res.append(i)

		return res
'''internal static class ByteArrayRocks{
	public static int[] Locate(this byte[] self, byte[] candidate){
		bool flag = ByteArrayRocks.IsEmptyLocate(self, candidate);
		int[] result;
		if (flag){
			result = ByteArrayRocks.Empty;
		}

		else{
		List<int> list = new List<int>();
		for (int i = 0; i < self.Length; i++){
			bool flag2 = !ByteArrayRocks.IsMatch(self, i, candidate);
			if (!flag2){
				list.Add(i);
			}
		}
		result = ((list.Count == 0) ? ByteArrayRocks.Empty : list.ToArray());
		}
	return result;
	}'''

def decrypt2(ciphertext, secretKey, iv):
    aesCipher = AES.new(secretKey, AES.MODE_CBC, iv)
    aesCipher.block_size = 128
    ciphertext = pad(ciphertext,128)
    data = aesCipher.decrypt(ciphertext)
    return data

# dnSpy copy method body copies some headers/metadata, which are commented out not just method body
method_body = bytearray(
	[
	#0x13, 0x30, 0x03, 0x00, 0x21, 0x01, 0x00, 0x00, 0x06, 0x00, 0x00, 0x11,
	0x00, 0x28, 0x10, 0x00,
	0x00, 0x06, 0x00, 0x28, 0x2F, 0x00, 0x00, 0x0A, 0x0C, 0x08, 0x2C, 0x14, 0x00, 0x72, 0xC3, 0x00,
	0x00, 0x70, 0x28, 0x30, 0x00, 0x00, 0x0A, 0x00, 0x15, 0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00,
	0x17, 0x0A, 0x28, 0x32, 0x00, 0x00, 0x0A, 0x6F, 0x33, 0x00, 0x00, 0x0A, 0x12, 0x00, 0x28, 0x08,
	0x00, 0x00, 0x06, 0x26, 0x06, 0x0D, 0x09, 0x2C, 0x14, 0x00, 0x72, 0xC3, 0x00, 0x00, 0x70, 0x28,
	0x30, 0x00, 0x00, 0x0A, 0x00, 0x15, 0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x28, 0x09, 0x00,
	0x00, 0x06, 0x13, 0x04, 0x11, 0x04, 0x2C, 0x14, 0x00, 0x72, 0xC3, 0x00, 0x00, 0x70, 0x28, 0x30,
	0x00, 0x00, 0x0A, 0x00, 0x15, 0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x8E, 0x16, 0xFE,
	0x01, 0x13, 0x05, 0x11, 0x05, 0x2C, 0x14, 0x00, 0x72, 0xCD, 0x00, 0x00, 0x70, 0x28, 0x30, 0x00,
	0x00, 0x0A, 0x00, 0x15, 0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x02, 0x16, 0x9A, 0x72, 0x11,
	0x01, 0x00, 0x70, 0x28, 0x13, 0x00, 0x00, 0x06, 0x28, 0x34, 0x00, 0x00, 0x0A, 0x13, 0x06, 0x11,
	0x06, 0x2C, 0x16, 0x00, 0x72, 0xC3, 0x00, 0x00, 0x70, 0x28, 0x30, 0x00, 0x00, 0x0A, 0x00, 0x15,
	0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x2B, 0x10, 0x00, 0x72, 0x6B, 0x01, 0x00, 0x70, 0x02,
	0x16, 0x9A, 0x28, 0x35, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x72, 0xE3, 0x01, 0x00, 0x70, 0x28, 0x0A,
	0x00, 0x00, 0x06, 0x0B, 0x07, 0x7E, 0x36, 0x00, 0x00, 0x0A, 0x28, 0x37, 0x00, 0x00, 0x0A, 0x13,
	0x07, 0x11, 0x07, 0x2C, 0x37, 0x00, 0x07, 0x72, 0xFD, 0x01, 0x00, 0x70, 0x28, 0x0B, 0x00, 0x00,
	0x06, 0x13, 0x08, 0x11, 0x08, 0x28, 0x38, 0x00, 0x00, 0x0A, 0x20, 0xE9, 0x00, 0x00, 0x00, 0xFE,
	0x01, 0x13, 0x09, 0x11, 0x09, 0x2C, 0x14, 0x00, 0x72, 0x33, 0x02, 0x00, 0x70, 0x28, 0x30, 0x00,
	0x00, 0x0A, 0x00, 0x15, 0x28, 0x31, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x2A]
	)
salt = bytearray([1,2,3,4,5,6,7,8])

pbkd = PBKDF2(method_body, salt, dkLen=256, count=1000)
key = pbkd[:32]
iv = pbkd[32:48]

f = open("ReMe.dll","rb")
memstream = f.read()
f.close()

candidate = b"THIS_IS_CSCG_NOT_A_MALWARE!"
array2 = byteRocks(memstream).Locate(candidate)
idx = array2[0] + len(candidate)
memstream = memstream[idx:]

f = open("dec.dll", "wb")
f.write(decrypt2(memstream,key,iv))
f.close()